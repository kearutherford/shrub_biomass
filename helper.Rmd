
<br>

# SPECIES

```{r}
input_data <- 

M1.lm <- lm(lnAGL ~ lnCA + lnHT, data = input_data)
b1start.M1.1 <- exp(M1.lm$coef[[1]])
b2start.M1.1 <- M1.lm$coef[[2]]
b3start.M1.1 <- M1.lm$coef[[3]]

M2.lm <- lm(lnAGL ~ lnCA, data = input_data)
b1start.M2.1 <- exp(M2.lm$coef[[1]])
b2start.M2.1 <- M2.lm$coef[[2]]
```

### NLS FIT

```{r}
ctrl <- nls.control(maxiter = 1500, tol = 1e-4, minFactor = 1e-10)

############################################################################
# model fit 1 (CA & HT)
############################################################################

# second set of starting values
b1start.M1.2 <- ((b1start.M1.1*0.15) + b1start.M1.1)
b2start.M1.2 <- ((b2start.M1.1*0.15) + b2start.M1.1)
b3start.M1.2 <- ((b3start.M1.1*0.15) + b3start.M1.1)

# set 1 starting values, default Gauss-Newton search algorithm
M1.1 <- nls(AGL.g ~ b1*(CA.m2^b2)*(Hgt.m^b3),
            start = list(b1 = b1start.M1.1, b2 = b2start.M1.1, b3 = b3start.M1.1),
            data = input_data,
            control = ctrl)
    
# set 2 starting values, default Gauss-Newton search algorithm
M1.2 <- nls(AGL.g ~ b1*(CA.m2^b2)*(Hgt.m^b3),
            start = list(b1 = b1start.M1.2, b2 = b2start.M1.2, b3 = b3start.M1.2),
            data = input_data,
            control = ctrl)

# set 1 starting values, port search algorithm
M1.3 <- nls(AGL.g ~ b1*(CA.m2^b2)*(Hgt.m^b3),
            start = list(b1 = b1start.M1.1, b2 = b2start.M1.1, b3 = b3start.M1.1),
            data = input_data,
            algorithm = 'port',
            control = ctrl)
 
# set 2 starting values, port search algorithm
M1.4 <- nls(AGL.g ~ b1*(CA.m2^b2)*(Hgt.m^b3),
            start = list(b1 = b1start.M1.2, b2 = b2start.M1.2, b3 = b3start.M1.2),
            data = input_data,
            algorithm = 'port',
            control = ctrl)

# check for coefficient equivalency
M1.1_sum <- summary(M1.1)
M1.2_sum <- summary(M1.2)
M1.3_sum <- summary(M1.3)
M1.4_sum <- summary(M1.4)

M1.1_coefs <- c(round(M1.1_sum$coef[1,1],2), round(M1.1_sum$coef[2,1],2), round(M1.1_sum$coef[3,1],2))
M1.2_coefs <- c(round(M1.2_sum$coef[1,1],2), round(M1.2_sum$coef[2,1],2), round(M1.2_sum$coef[3,1],2))
M1.3_coefs <- c(round(M1.3_sum$coef[1,1],2), round(M1.3_sum$coef[2,1],2), round(M1.3_sum$coef[3,1],2))
M1.4_coefs <- c(round(M1.4_sum$coef[1,1],2), round(M1.4_sum$coef[2,1],2), round(M1.4_sum$coef[3,1],2))

M1_check1 <- isTRUE(all.equal(M1.1_coefs, M1.2_coefs))
M1_check2 <- isTRUE(all.equal(M1.1_coefs, M1.3_coefs))
M1_check3 <- isTRUE(all.equal(M1.1_coefs, M1.4_coefs))

if(all(c(M1_check1, M1_check2, M1_check3)) != "TRUE") {
    stop('Global solution NOT found!')
} 

# check for SSE equivalency 
SSE_M1.1 <- round(sum(resid(M1.1)^2), -2)
SSE_M1.2 <- round(sum(resid(M1.2)^2), -2)
SSE_M1.3 <- round(sum(resid(M1.3)^2), -2)
SSE_M1.4 <- round(sum(resid(M1.4)^2), -2)

M1_sse_check1 <- isTRUE(all.equal(SSE_M1.1, SSE_M1.2))
M1_sse_check2 <- isTRUE(all.equal(SSE_M1.1, SSE_M1.3))
M1_sse_check3 <- isTRUE(all.equal(SSE_M1.1, SSE_M1.4))

if(all(c(M1_sse_check1, M1_sse_check2, M1_sse_check3)) != "TRUE") {
    stop('Global solution NOT found!')
} 

# Pseudo R2
meany <- mean(input_data$AGL.g)
SSY <- sum((input_data$AGL.g - meany)^2)
SSE_M1 <- sum(resid(M1.1)^2)
M1_R2 <- (1-(SSE_M1/SSY))

# outputs
M1_sum <- summary(M1.1)
M1_plots <- diag_plots_nl(model = M1.1, data = input_data, y = AGL.g, type = "nls")
M1_list <- list("summary" = M1_sum, "Pseudo_R2" = M1_R2, "diagnostic_plots" = M1_plots)


############################################################################
# model fit 2 (CA)
############################################################################
    
# second set of starting values
b1start.M2.2 <- ((b1start.M2.1*0.15) + b1start.M2.1)
b2start.M2.2 <- ((b2start.M2.1*0.15) + b2start.M2.1)
    
# set 1 starting values, default Gauss-Newton search algorithm
M2.1 <- nls(AGL.g ~ b1*(CA.m2^b2),
            start = list(b1 = b1start.M2.1, b2 = b2start.M2.1),
            data = input_data,
            control = ctrl)
    
# set 2 starting values, default Gauss-Newton search algorithm
M2.2 <- nls(AGL.g ~ b1*(CA.m2^b2),
            start = list(b1 = b1start.M2.2, b2 = b2start.M2.2),
            data = input_data,
            control = ctrl)

# set 1 starting values, port search algorithm
M2.3 <- nls(AGL.g ~ b1*(CA.m2^b2),
            start = list(b1 = b1start.M2.1, b2 = b2start.M2.1),
            data = input_data,
            algorithm = 'port',
            control = ctrl)
    
# set 2 starting values, port search algorithm
M2.4 <- nls(AGL.g ~ b1*(CA.m2^b2),
            start = list(b1 = b1start.M2.2, b2 = b2start.M2.2),
            data = input_data,
            algorithm = 'port',
            control = ctrl)

# check for coefficient equivalency
M2.1_sum <- summary(M2.1)
M2.2_sum <- summary(M2.2)
M2.3_sum <- summary(M2.3)
M2.4_sum <- summary(M2.4)

M2.1_coefs <- c(round(M2.1_sum$coef[1,1],2), round(M2.1_sum$coef[2,1],2))
M2.2_coefs <- c(round(M2.2_sum$coef[1,1],2), round(M2.2_sum$coef[2,1],2))
M2.3_coefs <- c(round(M2.3_sum$coef[1,1],2), round(M2.3_sum$coef[2,1],2))
M2.4_coefs <- c(round(M2.4_sum$coef[1,1],2), round(M2.4_sum$coef[2,1],2))

M2_check1 <- isTRUE(all.equal(M2.1_coefs, M2.2_coefs))
M2_check2 <- isTRUE(all.equal(M2.1_coefs, M2.3_coefs))
M2_check3 <- isTRUE(all.equal(M2.1_coefs, M2.4_coefs))

if(all(c(M2_check1, M2_check2, M2_check3)) != "TRUE") {
    stop('Global solution NOT found!')
}

# check for SSE equivalency 
SSE_M2.1 <- round(sum(resid(M2.1)^2), -2)
SSE_M2.2 <- round(sum(resid(M2.2)^2), -2)
SSE_M2.3 <- round(sum(resid(M2.3)^2), -2)
SSE_M2.4 <- round(sum(resid(M2.4)^2), -2)

M2_sse_check1 <- isTRUE(all.equal(SSE_M2.1, SSE_M2.2))
M2_sse_check2 <- isTRUE(all.equal(SSE_M2.1, SSE_M2.3))
M2_sse_check3 <- isTRUE(all.equal(SSE_M2.1, SSE_M2.4))

if(all(c(M2_sse_check1, M2_sse_check2, M2_sse_check3)) != "TRUE") {
    stop('Global solution NOT found!')
} 

# Pseudo R2
meany <- mean(input_data$AGL.g)
SSY <- sum((input_data$AGL.g - meany)^2)
SSE_M2 <- sum(resid(M2.1)^2)
M2_R2 <- (1-(SSE_M2/SSY))

# outputs
M2_sum <- summary(M2.1)
M2_plots <- diag_plots_nl(model = M2.1, data = input_data, y = AGL.g, type = "nls")
M2_list <- list("summary" = M2_sum, "Pseudo_R2" = M2_R2, "diagnostic_plots" = M2_plots)


############################################################################
# AIC values and rank
############################################################################

AIC_values <- AICc(M1.1, M2.1)
AIC_values <- AIC_values %>% arrange(AICc) %>% mutate(delta_AICc = AICc - AICc[1], AICc = round(AICc,3), delta_AICc = round(delta_AICc,3))

# create output list, ordered by AICc
n <- nrow(AIC_values)
return_list <- list(AIC_values)
    
for(i in 1:n) {
      
  model_no <- rownames(AIC_values)[i]
      
  if(model_no == "M1.1") {
    return_list[[length(return_list)+1]] <- M1_list
  } else if (model_no == "M2.1") {
    return_list[[length(return_list)+1]] <- M2_list
  }
        
}
    
list_names <- c("AICc_Ranks", rownames(AIC_values))
names(return_list) <- list_names

return_list
```

### GNLS FIT

```{r}
ctrl_1 <- gnlsControl(maxIter = 1500, tolerance = 1e-4, minScale = 1e-10, opt = "nlminb") # a port routine (program default)
ctrl_2 <- gnlsControl(maxIter = 1500, tolerance = 1e-4, minScale = 1e-10, opt = "optim") # Nelder-Mead routine 
  
############################################################################
# model fit 1
############################################################################
  
# second set of starting values
b1start.M1.2 <- ((b1start.M1.1*0.15) + b1start.M1.1)
b2start.M1.2 <- ((b2start.M1.1*0.15) + b2start.M1.1)
b3start.M1.2 <- ((b3start.M1.1*0.15) + b3start.M1.1)

# set 1 starting values, default port search algorithm
M1.1 <- gnls(AGL.g ~ b1*(CA.m2^b2)*(Hgt.m^b3),
             start = list(b1 = b1start.M1.1, b2 = b2start.M1.1, b3 = b3start.M1.1),
             data = input_data,
             weights = varPower(),
             control = ctrl_1)

# set 2 starting values, default port search algorithm
M1.2 <- gnls(AGL.g ~ b1*(CA.m2^b2)*(Hgt.m^b3),
             start = list(b1 = b1start.M1.2, b2 = b2start.M1.2, b3 = b3start.M1.2),
             data = input_data,
             weights = varPower(),
             control = ctrl_1)

# set 1 starting values, Nelder-Mead search algorithm
M1.3 <- gnls(AGL.g ~ b1*(CA.m2^b2)*(Hgt.m^b3),
             start = list(b1 = b1start.M1.1, b2 = b2start.M1.1, b3 = b3start.M1.1),
             data = input_data,
             weights = varPower(),
             control = ctrl_2)

# set 2 starting values, Nelder-Mead search algorithm
M1.4 <- gnls(AGL.g ~ b1*(CA.m2^b2)*(Hgt.m^b3),
             start = list(b1 = b1start.M1.2, b2 = b2start.M1.2, b3 = b3start.M1.2),
             data = input_data,
             weights = varPower(),
             control = ctrl_2)

# check for coefficient equivalency
M1.1_coefs <- c(round(M1.1$coef[[1]],2), round(M1.1$coef[[2]],2), round(M1.1$coef[[3]],2))
M1.2_coefs <- c(round(M1.2$coef[[1]],2), round(M1.2$coef[[2]],2), round(M1.2$coef[[3]],2))
M1.3_coefs <- c(round(M1.3$coef[[1]],2), round(M1.3$coef[[2]],2), round(M1.3$coef[[3]],2))
M1.4_coefs <- c(round(M1.4$coef[[1]],2), round(M1.4$coef[[2]],2), round(M1.4$coef[[3]],2))

M1_check1 <- isTRUE(all.equal(M1.1_coefs, M1.2_coefs))
M1_check2 <- isTRUE(all.equal(M1.1_coefs, M1.3_coefs))
M1_check3 <- isTRUE(all.equal(M1.1_coefs, M1.4_coefs))

if(all(c(M1_check1, M1_check2, M1_check3)) != "TRUE") {
    stop('Global solution NOT found!')
} 

# check for SSE equivalency 
SSE_M1.1 <- round(sum(resid(M1.1)^2), -2)
SSE_M1.2 <- round(sum(resid(M1.2)^2), -2)
SSE_M1.3 <- round(sum(resid(M1.3)^2), -2)
SSE_M1.4 <- round(sum(resid(M1.4)^2), -2)

M1_sse_check1 <- isTRUE(all.equal(SSE_M1.1, SSE_M1.2))
M1_sse_check2 <- isTRUE(all.equal(SSE_M1.1, SSE_M1.3))
M1_sse_check3 <- isTRUE(all.equal(SSE_M1.1, SSE_M1.4))

if(all(c(M1_sse_check1, M1_sse_check2, M1_sse_check3)) != "TRUE") {
    stop('Global solution NOT found!')
}

# Pseudo R2
meany <- mean(input_data$AGL.g)
SSY <- sum((input_data$AGL.g - meany)^2)
SSE_M1 <- sum(resid(M1.1)^2)
M1_R2 <- (1-(SSE_M1/SSY))

# outputs
M1_sum <- summary(M1.1)
M1_plots <- diag_plots_nl(model = M1.1, data = input_data, y = AGL.g, type = "gnls")
M1_list <- list("summary" = M1_sum, "Pseudo_R2" = M1_R2, "diagnostic_plots" = M1_plots)


############################################################################
# model fit 2
############################################################################
    
# second set of starting values
b1start.M2.2 <- ((b1start.M2.1*0.15) + b1start.M2.1)
b2start.M2.2 <- ((b2start.M2.1*0.15) + b2start.M2.1)
    
# set 1 starting values, default port search algorithm
M2.1 <- gnls(AGL.g ~ b1*(CA.m2^b2),
             start = list(b1 = b1start.M2.1, b2 = b2start.M2.1),
             data = input_data,
             weights = varPower(),
             control = ctrl_1)
    
# set 2 starting values, default port search algorithm
M2.2 <- gnls(AGL.g ~ b1*(CA.m2^b2),
             start = list(b1 = b1start.M2.2, b2 = b2start.M2.2),
             data = input_data,
             weights = varPower(),
             control = ctrl_1)

# set 1 starting values, Nelder-Mead search algorithm
M2.3 <- gnls(AGL.g ~ b1*(CA.m2^b2),
             start = list(b1 = b1start.M2.1, b2 = b2start.M2.1),
             data = input_data,
             weights = varPower(),
             control = ctrl_2)
    
# set 2 starting values, Nelder-Mead search algorithm
M2.4 <- gnls(AGL.g ~ b1*(CA.m2^b2),
             start = list(b1 = b1start.M2.2, b2 = b2start.M2.2),
             data = input_data,
             weights = varPower(),
             control = ctrl_2)

# check for coefficient equivalency
M2.1_coefs <- c(round(M2.1$coef[[1]],2), round(M2.1$coef[[2]],2))
M2.2_coefs <- c(round(M2.2$coef[[1]],2), round(M2.2$coef[[2]],2))
M2.3_coefs <- c(round(M2.3$coef[[1]],2), round(M2.3$coef[[2]],2))
M2.4_coefs <- c(round(M2.4$coef[[1]],2), round(M2.4$coef[[2]],2))

M2_check1 <- isTRUE(all.equal(M2.1_coefs, M2.2_coefs))
M2_check2 <- isTRUE(all.equal(M2.1_coefs, M2.3_coefs))
M2_check3 <- isTRUE(all.equal(M2.1_coefs, M2.4_coefs))

if(all(c(M2_check1, M2_check2, M2_check3)) != "TRUE") {
    stop('Global solution NOT found!')
}

# check for SSE equivalency 
SSE_M2.1 <- round(sum(resid(M2.1)^2), -2)
SSE_M2.2 <- round(sum(resid(M2.2)^2), -2)
SSE_M2.3 <- round(sum(resid(M2.3)^2), -2)
SSE_M2.4 <- round(sum(resid(M2.4)^2), -2)

M2_sse_check1 <- isTRUE(all.equal(SSE_M2.1, SSE_M2.2))
M2_sse_check2 <- isTRUE(all.equal(SSE_M2.1, SSE_M2.3))
M2_sse_check3 <- isTRUE(all.equal(SSE_M2.1, SSE_M2.4))

if(all(c(M2_sse_check1, M2_sse_check2, M2_sse_check3)) != "TRUE") {
    stop('Global solution NOT found!')
}

# Pseudo R2
meany <- mean(input_data$AGL.g)
SSY <- sum((input_data$AGL.g - meany)^2)
SSE_M2 <- sum(resid(M2.1)^2)
M2_R2 <- (1-(SSE_M2/SSY))

# outputs
M2_sum <- summary(M2.1)
M2_plots <- diag_plots_nl(model = M2.1, data = input_data, y = AGL.g, type = "gnls")
M2_list <- list("summary" = M2_sum, "Pseudo_R2" = M2_R2, "diagnostic_plots" = M2_plots)


############################################################################
# AIC values and rank
############################################################################

AIC_values <- AICc(M1.1, M2.1)
AIC_values <- AIC_values %>% arrange(AICc) %>% mutate(delta_AICc = AICc - AICc[1], AICc = round(AICc,3), delta_AICc = round(delta_AICc,3))

# create output list, ordered by AICc
n <- nrow(AIC_values)
return_list <- list(AIC_values)
    
for(i in 1:n) {
      
  model_no <- rownames(AIC_values)[i]
      
  if(model_no == "M1.1") {
    return_list[[length(return_list)+1]] <- M1_list
  } else if (model_no == "M2.1") {
    return_list[[length(return_list)+1]] <- M2_list
  }
        
}
    
list_names <- c("AICc_Ranks", rownames(AIC_values))
names(return_list) <- list_names
    
return_list
```
